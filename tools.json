[
  {
    "name": "usaw_rankings",
    "description": "Get USAW rankings by weight class and date range. weight_class accepts: ID (81), name (\"Men's 81kg\"), or comma-separated list (\"81, 89\"). WSO filter applied client-side. Returns rankings sorted by total.",
    "params": "weight_class!, date_range_start!, date_range_end = \"\", limit = 50, athlete_name = \"\", club = \"\", level = \"\", wso = \"\"",
    "implementation": "const API_TOKEN = '14ced0f3-421f-4acf-94ad-cc63a371af19';\nconst BASE_URL = 'https://admin-usaw-rankings.sport80.com';\nvar pageSize = input.limit || 50;\n\nfunction parseWeightClasses(wcInput) {\n  if (!wcInput) return null;\n  var inputs = String(wcInput).split(',').map(function(s) { return s.trim(); }).filter(function(s) { return s; });\n  if (inputs.length === 0) return null;\n  var ids = [];\n  inputs.forEach(function(val) {\n    if (/^\\d+$/.test(val)) {\n      ids.push(parseInt(val));\n    } else {\n      var match = val.match(/(\\d+)\\s*kg/i) || val.match(/(\\d+)/);\n      if (match) ids.push(parseInt(match[1]));\n    }\n  });\n  return ids.length > 0 ? ids : null;\n}\n\nfunction fetchRankingsForClass(weightClassId, dateStart, dateEnd, athleteName, club, level) {\n  var allRankings = [], page = 0, hasMore = true;\n  while (hasMore) {\n    var url = BASE_URL + '/api/categories/all/rankings/table/data?p=' + page + '&l=' + pageSize + '&s=' + encodeURIComponent(athleteName || '');\n    var payload = { columns: [], filters: { date_range_start: dateStart, date_range_end: dateEnd, weight_class: weightClassId } };\n    if (club && String(club).trim()) payload.filters.club = String(club).trim();\n    if (level && String(level).trim()) payload.filters.level = level;\n    var resp = UrlFetchApp.fetch(url, { method: 'POST', headers: { 'x-api-token': API_TOKEN, 'Content-Type': 'application/json' }, payload: JSON.stringify(payload), muteHttpExceptions: true });\n    if (resp.getResponseCode() !== 200) return { error: 'API returned ' + resp.getResponseCode() };\n    var data; try { data = JSON.parse(resp.getContentText()); } catch (e) { return { error: 'Invalid JSON response' }; }\n    var rankings = data.data || [];\n    allRankings = allRankings.concat(rankings.map(function(r) {\n      var historyId = null;\n      if (r.action && r.action[0] && r.action[0].route) { var match = r.action[0].route.match(/\\/member\\/(\\d+)/); if (match) historyId = match[1]; }\n      return { rank: r.rank, name: r.name, gender: r.gender, club: r.club, total: r.total, lift_date: r.lift_date, member_id: r.membership, lifter_history_id: historyId, level: r.level, wso: r.wso, weight_class_id: weightClassId };\n    }));\n    hasMore = rankings.length > 0 && rankings.length >= pageSize;\n    page++;\n    if (page > 100) break;\n  }\n  return { rankings: allRankings };\n}\n\nif (!input.date_range_start) return { error: 'date_range_start is required' };\nvar dateEnd = input.date_range_end || new Date().toISOString().split('T')[0];\n\nvar weightClassIds = parseWeightClasses(input.weight_class);\nif (!weightClassIds || weightClassIds.length === 0) {\n  return { error: 'weight_class is required. Use weight value (81), name (\"81kg\"), or comma-separated list (\"81, 89\").' };\n}\nthinking('Resolved weight classes: ' + weightClassIds.join(', '));\n\nvar allRankings = [], fetchErrors = [];\nweightClassIds.forEach(function(wcId) {\n  thinking('Fetching rankings for weight class ' + wcId + '...');\n  var result = fetchRankingsForClass(wcId, input.date_range_start, dateEnd, input.athlete_name, input.club, input.level);\n  if (result.error) fetchErrors.push({ weight_class_id: wcId, error: result.error });\n  else allRankings = allRankings.concat(result.rankings);\n});\n\nif (input.wso && String(input.wso).trim()) {\n  var wsoFilter = input.wso.toLowerCase();\n  var beforeCount = allRankings.length;\n  allRankings = allRankings.filter(function(r) { return r.wso && r.wso.toLowerCase().includes(wsoFilter); });\n  thinking('Filtered WSO: ' + beforeCount + ' -> ' + allRankings.length + ' for \"' + input.wso + '\"');\n}\n\nallRankings.sort(function(a, b) { return (b.total || 0) - (a.total || 0); });\nthinking('Found ' + allRankings.length + ' total rankings');\n\nvar response = { rankings: allRankings, weight_classes: weightClassIds, count: allRankings.length, hints: { nextTools: ['usaw_lifter_history: pass lifter_history_id for athlete competition history'] } };\nif (fetchErrors.length > 0) response.fetch_warnings = fetchErrors;\nreturn response;",
    "enabled": true,
    "returns": "{rankings: [{rank: number, name: string, gender: \"M\"|\"F\", club: string, total: number, lift_date: \"YYYY-MM-DD\", member_id: string, lifter_history_id: string, level: string, wso: string}], page: number, hasMore: boolean} | {error: string}"
  },
  {
    "name": "usaw_weight_classes",
    "description": "Get USAW weight class IDs and labels. Use id as weight_class_id in usaw_rankings. Filter by gender to reduce list.",
    "params": "gender = \"\"",
    "implementation": "const API_TOKEN = '14ced0f3-421f-4acf-94ad-cc63a371af19';\nconst url = 'https://admin-usaw-rankings.sport80.com/api/categories/rankings/table';\n\nthinking('Fetching USAW weight classes');\n\nconst response = UrlFetchApp.fetch(url, {\n  headers: { 'x-api-token': API_TOKEN },\n  muteHttpExceptions: true\n});\n\nif (response.getResponseCode() !== 200) {\n  return { error: 'API returned ' + response.getResponseCode() };\n}\n\nlet data;\ntry { data = JSON.parse(response.getContentText()); }\ncatch (e) { return { error: 'Invalid JSON response', details: response.getContentText().substring(0, 200) }; }\n\nconst wcFilter = data.filters.find(f => f.name === 'weight_class');\nif (!wcFilter) return { error: 'weight_class filter not found in API response' };\n\nlet classes = wcFilter.items.map(i => ({\n  id: i.value,\n  label: i.text,\n  gender: i.text.toLowerCase().includes('women') || i.text.toLowerCase().includes('girl') ? 'F' : 'M'\n})).filter(c => !c.label.includes('(Inactive)'));\n\nif (input.gender) {\n  classes = classes.filter(c => c.gender === input.gender.toUpperCase());\n}\n\nthinking('Found ' + classes.length + ' weight classes');\nreturn { \n  classes: classes,\n  hints: { nextTools: ['usaw_rankings: pass id as weight_class_id to get rankings for that class'] }\n};",
    "enabled": true,
    "returns": "[{id: number, label: string, gender: \"M\"|\"F\"}] | {error: string}"
  },
  {
    "name": "usaw_lifter_history",
    "description": "Get competition history for ONE athlete by lifter_history_id (from usaw_rankings). For multiple athletes, use usaw_bulk_lifter_history.",
    "params": "lifter_history_id!",
    "implementation": "const API_TOKEN = '14ced0f3-421f-4acf-94ad-cc63a371af19';\nconst url = 'https://admin-usaw-rankings.sport80.com/api/athletes/' + input.lifter_history_id + '/table/data';\n\nthinking('Fetching lift history for athlete ' + input.lifter_history_id);\n\nconst response = UrlFetchApp.fetch(url, {\n  method: 'POST',\n  headers: { 'x-api-token': API_TOKEN, 'Content-Type': 'application/json' },\n  payload: '{}',\n  muteHttpExceptions: true\n});\n\nif (response.getResponseCode() !== 200) {\n  return { error: 'API returned ' + response.getResponseCode(), details: response.getContentText().substring(0, 500) };\n}\n\nlet data;\ntry { data = JSON.parse(response.getContentText()); }\ncatch (e) { return { error: 'Invalid JSON response', details: response.getContentText().substring(0, 200) }; }\n\nconst history = (data.data || []).map(r => ({\n  meet: r.meet, date: r.date, age_category: r.age_category,\n  body_weight: r['body_weight_(kg)'],\n  snatch: [r.snatch_lift_1, r.snatch_lift_2, r.snatch_lift_3],\n  clean_jerk: [r['c&j_lift_1'], r['c&j_lift_2'], r['c&j_lift_3']],\n  best_snatch: r.best_snatch, best_cj: r['best_c&j'], total: r.total\n}));\n\nthinking('Found ' + history.length + ' competition results');\nreturn history;",
    "enabled": true,
    "returns": "[{meet: string, date: \"YYYY-MM-DD\", age_category: string, body_weight: number, snatch: [number|null, number|null, number|null], clean_jerk: [number|null, number|null, number|null], best_snatch: number, best_cj: number, total: number}] | {error: string}"
  },
  {
    "name": "iwf_world_records",
    "description": "Get IWF World Records by gender and age group. Use record_type=\"current\" for ratified records, \"progress\" for pending. Note: IWF weight classes differ from USAW.",
    "params": "gender!, age_group = \"Senior\", record_type = \"current\"",
    "implementation": "const genderMap = { 'm': 'm', 'M': 'm', 'male': 'm', 'f': 'w', 'F': 'w', 'w': 'w', 'W': 'w', 'female': 'w', 'women': 'w' };\nconst g = genderMap[input.gender];\nif (!g) return { error: 'Invalid gender. Use: M, F, m, f, male, female, w, women' };\n\nconst ageGroup = input.age_group || 'Senior';\nconst recordType = input.record_type || 'current';\n\nconst url = 'https://iwf.sport/results/world-records/?ranking_curprog=' + recordType + '&ranking_agegroup=' + encodeURIComponent(ageGroup) + '&ranking_gender=' + g;\n\nthinking('Fetching IWF World Records: ' + ageGroup + ' ' + (g === 'w' ? 'Women' : 'Men'));\n\nconst response = UrlFetchApp.fetch(url, { muteHttpExceptions: true });\n\nif (response.getResponseCode() !== 200) {\n  return { error: 'IWF returned ' + response.getResponseCode() };\n}\n\nconst html = response.getContentText();\nconst category = ageGroup + ' ' + (g === 'w' ? 'Women' : 'Men');\n\n// Validate we got expected content\nif (!html.includes('world-records') && !html.includes('card')) {\n  thinking('WARNING: IWF page structure may have changed');\n  return { error: 'IWF page structure unexpected - may need parser update', details: html.substring(0, 500) };\n}\n\n// Parse weight classes\nconst wcMatches = [...html.matchAll(/<h2>(\\d+\\s*\\+?)\\s*kg<\\/h2>/g)].map(m => m[1].trim());\n\n// Parse records\nconst records = [];\nconst cardSections = html.split(/<div class=\"card\">/);\n\nfor (let i = 1; i < cardSections.length; i++) {\n  const c = cardSections[i];\n  if (c.includes('card__legend')) continue;\n  \n  const lift = (c.match(/>\\s*(Snatch|C&J|Total)\\s*</) || [])[1];\n  const weight = (c.match(/Record:\\s*<\\/span>(\\d+)\\s*kg/) || [])[1];\n  if (!lift || !weight) continue;\n  \n  const athlete = (c.match(/<strong>([A-Z][A-Z]+\\s+[A-Za-z][A-Za-z\\s]*)<\\/strong>/) || [])[1]?.trim() || '';\n  const nation = (c.match(/alt=\"([A-Z]{3})\"/) || [])[1] || '';\n  const eventMatch = c.match(/<strong>\\s*([A-Z][a-z]{2}\\s+\\d{2},\\s+\\d{4})\\s*-\\s*([^<]+)<\\/strong>/);\n  \n  const wcIndex = Math.floor(records.length / 3);\n  records.push({\n    category: category,\n    weight_class: wcMatches[wcIndex] || 'unknown',\n    lift: lift === 'C&J' ? 'Clean & Jerk' : lift,\n    record_kg: parseInt(weight),\n    athlete: athlete,\n    nation: nation,\n    event_date: eventMatch?.[1]?.trim() || '',\n    location: eventMatch?.[2]?.trim() || ''\n  });\n}\n\n// Validate results\nif (records.length === 0) {\n  thinking('WARNING: No records parsed - IWF HTML structure may have changed');\n  return { error: 'Failed to parse IWF records - page structure may have changed', details: html.substring(0, 1000) };\n}\n\nconst expectedPerClass = 3;\nif (records.length % expectedPerClass !== 0) {\n  thinking('WARNING: Record count ' + records.length + ' not divisible by 3 - some records may be missing');\n}\n\nthinking('Found ' + records.length + ' world records');\nreturn records;",
    "enabled": true,
    "returns": "[{category: string, weight_class: string, lift: \"Snatch\"|\"Clean & Jerk\"|\"Total\", record_kg: number, athlete: string, nation: string, event_date: string, location: string}] | {error: string}"
  },
  {
    "name": "usaw_search_athlete",
    "description": "Search for athlete by name across weight classes. REQUIRES gender (\"M\" or \"F\") to limit API calls (~148 classes per gender). Optional age_category (\"Youth\", \"Junior\", \"Senior\", \"Masters\") further reduces scope to ~20-40 classes.",
    "params": "athlete_name!, gender!, date_range_start!, date_range_end = \"\", age_category = \"\"",
    "implementation": "const API_TOKEN = '14ced0f3-421f-4acf-94ad-cc63a371af19';\nconst BASE_URL = 'https://admin-usaw-rankings.sport80.com';\nconst MAX_CLASSES = 60, PAGE_SIZE = 50;\n\nconst g = (input.gender || '').toUpperCase();\nif (g !== 'M' && g !== 'F') return { error: 'gender required: M or F' };\n\nthinking('Fetching weight classes');\nconst wcResp = UrlFetchApp.fetch(BASE_URL + '/api/categories/rankings/table', {\n  headers: { 'x-api-token': API_TOKEN }, muteHttpExceptions: true\n});\nif (wcResp.getResponseCode() !== 200) return { error: 'Failed: ' + wcResp.getResponseCode() };\n\nlet wcData;\ntry { wcData = JSON.parse(wcResp.getContentText()); }\ncatch (e) { return { error: 'Invalid JSON' }; }\n\nlet classes = wcData.filters.find(f => f.name === 'weight_class').items.filter(i => !i.text.includes('(Inactive)'));\nclasses = classes.filter(i => {\n  const t = i.text.toLowerCase();\n  return (g === 'F') === (t.includes('women') || t.includes('girl'));\n});\n\nif (input.age_category) {\n  const ac = input.age_category.toLowerCase();\n  classes = classes.filter(i => {\n    const t = i.text.toLowerCase();\n    if (ac === 'youth') return t.includes('youth');\n    if (ac === 'junior') return t.includes('junior');\n    if (ac === 'senior' || ac === 'open') return !t.includes('youth') && !t.includes('junior') && !t.includes('masters');\n    if (ac === 'masters') return t.includes('masters');\n    return true;\n  });\n}\n\nif (classes.length > MAX_CLASSES) return { error: 'Too many classes (' + classes.length + '). Add age_category.' };\n\nthinking('Searching ' + classes.length + ' classes');\nconst results = [], dateEnd = input.date_range_end || new Date().toISOString().split('T')[0], seen = new Set();\n\nfor (const wc of classes) {\n  var pg = 0, more = true;\n  while (more) {\n    thinking('Searching ' + wc.text + ' p' + pg);\n    const resp = UrlFetchApp.fetch(BASE_URL + '/api/categories/all/rankings/table/data?p=' + pg + '&l=' + PAGE_SIZE + '&s=' + encodeURIComponent(input.athlete_name), {\n      method: 'POST', headers: { 'x-api-token': API_TOKEN, 'Content-Type': 'application/json' },\n      payload: JSON.stringify({ columns: [], filters: { date_range_start: input.date_range_start, date_range_end: dateEnd, weight_class: wc.value } }),\n      muteHttpExceptions: true\n    });\n    if (resp.getResponseCode() !== 200) break;\n    let data; try { data = JSON.parse(resp.getContentText()); } catch (e) { break; }\n    var pr = data.data || [];\n    pr.forEach(r => {\n      const key = r.membership + '|' + wc.value; if (seen.has(key)) return; seen.add(key);\n      const t = wc.text.toLowerCase();\n      let ageCat = t.includes('youth') ? 'Youth' : t.includes('junior') ? 'Junior' : t.includes('masters') ? 'Masters' : 'Senior';\n      results.push({ weight_class_id: wc.value, weight_class: wc.text, age_category: ageCat, rank: r.rank, name: r.name, total: r.total, lift_date: r.lift_date, member_id: r.membership, lifter_history_id: r.action?.[0]?.route?.match(/member\\/(\\d+)/)?.[1] || null });\n    });\n    more = pr.length > 0 && pr.length >= PAGE_SIZE; pg++; if (pg > 20) break;\n  }\n}\n\nthinking('Found ' + results.length + ' matches');\nreturn { results, count: results.length, classes_searched: classes.length, hints: { nextTools: ['usaw_lifter_history: pass lifter_history_id', 'usaw_rankings: pass weight_class_id'] } };",
    "enabled": true,
    "returns": "[{weight_class_id: number, weight_class: string, age_category: \"Youth\"|\"Junior\"|\"Senior\"|\"Masters\", rank: number, name: string, total: number, lift_date: \"YYYY-MM-DD\", member_id: string, lifter_history_id: string}] | {error: string}"
  },
  {
    "name": "usaw_bulk_lifter_history",
    "description": "Get competition history for multiple athletes in one call. Pass comma-separated lifter_history_ids (from usaw_rankings or usaw_search_athlete). Max 10 IDs recommended to avoid timeout.",
    "params": "lifter_history_ids!",
    "implementation": "const API_TOKEN = '14ced0f3-421f-4acf-94ad-cc63a371af19';\nconst MAX_IDS = 10000;\n\nconst ids = input.lifter_history_ids.split(',').map(s => s.trim()).filter(Boolean);\nif (ids.length > MAX_IDS) {\n  return { error: 'Max ' + MAX_IDS + ' IDs allowed. Got: ' + ids.length };\n}\nif (ids.length === 0) {\n  return { error: 'No valid IDs provided' };\n}\n\nconst results = [];\nfor (const id of ids) {\n  thinking('Fetching history for ' + id + ' (' + (results.length + 1) + '/' + ids.length + ')');\n  const url = 'https://admin-usaw-rankings.sport80.com/api/athletes/' + id + '/table/data';\n  const resp = UrlFetchApp.fetch(url, {\n    method: 'POST',\n    headers: { 'x-api-token': API_TOKEN, 'Content-Type': 'application/json' },\n    payload: '{}',\n    muteHttpExceptions: true\n  });\n\n  if (resp.getResponseCode() === 200) {\n    let data;\n    try { data = JSON.parse(resp.getContentText()); }\n    catch (e) { results.push({ lifter_history_id: id, history: null, error: 'Invalid JSON' }); continue; }\n    \n    results.push({\n      lifter_history_id: id,\n      history: (data.data || []).map(r => ({\n        meet: r.meet, date: r.date, age_category: r.age_category,\n        body_weight: r['body_weight_(kg)'],\n        snatch: [r.snatch_lift_1, r.snatch_lift_2, r.snatch_lift_3],\n        clean_jerk: [r['c&j_lift_1'], r['c&j_lift_2'], r['c&j_lift_3']],\n        best_snatch: r.best_snatch, best_cj: r['best_c&j'], total: r.total\n      }))\n    });\n  } else {\n    results.push({ lifter_history_id: id, history: null, error: 'API returned ' + resp.getResponseCode() });\n  }\n}\n\nthinking('Fetched history for ' + results.length + ' athletes');\nreturn results;",
    "enabled": true,
    "returns": "[{lifter_history_id: string, history: [{meet: string, date: \"YYYY-MM-DD\", age_category: string, body_weight: number, snatch: [number|null x3], clean_jerk: [number|null x3], best_snatch: number, best_cj: number, total: number}] | null, error?: string}]"
  },
  {
    "name": "usaw_upcoming_events",
    "description": "List upcoming USAW events with registration info. Returns event_id and entries_id for use with usaw_event_entries. Optional filters: name_filter (substring), state.",
    "params": "from_date = \"\", limit = 50, name_filter = \"\", state = \"\"",
    "implementation": "var BASE_URL = 'https://usaweightlifting.sport80.com/api/public/events/locator/data';\nvar pageSize = input.limit || 50;\nvar fromDate = input.from_date || new Date().toISOString().split('T')[0];\n\nthinking('Fetching upcoming USAW events from ' + fromDate);\n\nvar allEvents = [];\nvar page = 0;\nvar hasMore = true;\n\nwhile (hasMore) {\n  thinking('Fetching page ' + page + ' (' + allEvents.length + ' events so far)');\n\n  var url = BASE_URL + '?p=' + page + '&i=' + pageSize + '&s=&l=&d=10&f=';\n\n  var boundary = '----WebKitFormBoundary' + Math.random().toString(36).substring(2);\n  var payload = '--' + boundary + '\\r\\n' +\n    'Content-Disposition: form-data; name=\"from_date\"\\r\\n\\r\\n' +\n    fromDate + '\\r\\n' +\n    '--' + boundary + '--';\n\n  var resp = UrlFetchApp.fetch(url, {\n    method: 'POST',\n    contentType: 'multipart/form-data; boundary=' + boundary,\n    payload: payload,\n    muteHttpExceptions: true\n  });\n\n  if (resp.getResponseCode() !== 200) {\n    return { error: 'API returned ' + resp.getResponseCode(), details: resp.getContentText().substring(0, 200) };\n  }\n\n  var data;\n  try { data = JSON.parse(resp.getContentText()); }\n  catch (e) { return { error: 'Invalid JSON', details: resp.getContentText().substring(0, 200) }; }\n\n  var events = data.data || [];\n  events.forEach(function(e) {\n    var entriesAction = e.actions ? e.actions.find(function(a) { return a.text === 'Entry List'; }) : null;\n    var entriesUrl = entriesAction ? entriesAction.url : null;\n    var eventId = e.id, entriesId = null;\n    if (entriesUrl) {\n      var match = entriesUrl.match(/\\/events\\/(\\d+)\\/entries\\/(\\d+)/);\n      if (match) { eventId = match[1]; entriesId = match[2]; }\n    }\n\n    var evt = {\n      event_id: String(eventId),\n      entries_id: entriesId,\n      name: e.name,\n      subtitle: e.subtitle,\n      address: e.address,\n      email: e.email,\n      img_url: e.img_url\n    };\n\n    // Apply filters\n    if (input.name_filter && evt.name && !evt.name.toLowerCase().includes(input.name_filter.toLowerCase())) return;\n    if (input.state && evt.address && !evt.address.toLowerCase().includes(input.state.toLowerCase())) return;\n\n    allEvents.push(evt);\n  });\n\n  hasMore = events.length > 0 && events.length >= (data.items_per_page || pageSize);\n  page++;\n  if (page > 100) break;\n}\n\nthinking('Found ' + allEvents.length + ' upcoming events');\n\nreturn {\n  events: allEvents,\n  from_date: fromDate,\n  count: allEvents.length,\n  hints: { nextTools: ['usaw_event_entries: pass event_id and entries_id for registered lifters'] }\n};",
    "enabled": true,
    "returns": "{events: [{event_id: string, name: string, start_date: \"YYYY-MM-DD\", end_date: \"YYYY-MM-DD\", location: string, entries_url: string | null}], page: number, hasMore: boolean} | {error: string}"
  },
  {
    "name": "usaw_wso_records",
    "description": "Get WSO all-time best lifts (snatch, C&J, total) per weight class. Fetches rankings filtered by WSO, then lifter history for each top lifter to extract individual lift bests.",
    "params": "wso!, gender = \"\", age_category = \"\", years_back = 10",
    "implementation": "function _main(\n  module = globalThis.__getCurrentModule(),\n  exports = module.exports,\n  log = globalThis.__getModuleLogFunction?.(module) || (() => {})\n) {\n  const API_TOKEN = '14ced0f3-421f-4acf-94ad-cc63a371af19';\n  const BASE_URL = 'https://admin-usaw-rankings.sport80.com';\n\n  // Validate required WSO parameter\n  if (!input.wso || !input.wso.trim()) {\n    return { error: 'wso is required', details: 'Provide the WSO name (e.g., \"Pacific Weightlifting Association\")' };\n  }\n  const wsoName = input.wso.trim();\n\n  // Validate WSO name length\n  if (wsoName.length > 200) {\n    return {\n      error: 'WSO name too long',\n      details: 'Maximum 200 characters allowed',\n      hints: {\n        provided: wsoName.substring(0, 50) + '...'\n      }\n    };\n  }\n\n  // Get weight classes\n  thinking('Fetching weight classes');\n  const wcResp = UrlFetchApp.fetch(BASE_URL + '/api/categories/rankings/table', {\n    headers: { 'x-api-token': API_TOKEN },\n    muteHttpExceptions: true\n  });\n\n  if (wcResp.getResponseCode() !== 200) {\n    return { error: 'Failed to fetch weight classes', details: 'API returned ' + wcResp.getResponseCode() };\n  }\n\n  let wcData;\n  try {\n    wcData = JSON.parse(wcResp.getContentText());\n  } catch (e) {\n    return { error: 'Invalid JSON from weight classes API', details: wcResp.getContentText().substring(0, 200) };\n  }\n\n  // Find weight class filter with null safety\n  const wcFilter = wcData.filters.find(f => f.name === 'weight_class');\n  if (!wcFilter || !wcFilter.items) {\n    return {\n      error: 'No weight class filter found in API response',\n      details: 'USAW API structure may have changed',\n      hints: {\n        message: 'This tool may need updating if USAW changed their API',\n        action: 'Report this issue if it persists'\n      }\n    };\n  }\n\n  let classes = wcFilter.items.filter(i => !i.text.includes('(Inactive)'));\n\n  if (classes.length === 0) {\n    return {\n      error: 'No active weight classes found',\n      details: 'All weight classes are marked inactive',\n      hints: {\n        suggestion: 'Check USAW website for current weight class definitions'\n      }\n    };\n  }\n\n  // Filter by gender if provided\n  if (input.gender) {\n    const g = input.gender.toUpperCase();\n    if (g !== 'M' && g !== 'F') {\n      return { error: 'Invalid gender', details: 'Use \"M\" or \"F\"' };\n    }\n    const isFemale = g === 'F';\n    const originalCount = classes.length;\n    classes = classes.filter(i => {\n      const textLower = i.text.toLowerCase();\n      const classIsFemale = textLower.includes('women') || textLower.includes('girl');\n      return isFemale === classIsFemale;\n    });\n    thinking('Filtered to ' + classes.length + ' weight classes for gender ' + g + ' (from ' + originalCount + ')');\n\n  }\n\n  // Filter by age_category if provided\n  if (input.age_category) {\n    const ageCat = input.age_category.toLowerCase();\n    classes = classes.filter(i => {\n      const textLower = i.text.toLowerCase();\n      if (ageCat === 'youth') return textLower.includes('youth');\n      if (ageCat === 'junior') return textLower.includes('junior');\n      if (ageCat === 'senior' || ageCat === 'open') return !textLower.includes('youth') && !textLower.includes('junior') && !textLower.includes('masters');\n      if (ageCat === 'masters') return textLower.includes('masters');\n      return true;\n    });\n  }\n\n  // Safety limit\n  const MAX_CLASSES = 60;\n  if (classes.length > MAX_CLASSES) {\n    return { error: 'Too many weight classes (' + classes.length + ')', details: 'Add gender and/or age_category filter to reduce scope below ' + MAX_CLASSES };\n  }\n\n  thinking('Searching ' + classes.length + ' weight classes for WSO: ' + wsoName);\n\n  // Calculate date range\n  const yearsBack = input.years_back || 10;\n  const endDate = new Date().toISOString().split('T')[0];\n  const startDate = new Date(Date.now() - yearsBack * 365.25 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];\n\n  const startTime = Date.now();\n\n  // PHASE 1: Build all ranking requests for all weight classes\n  thinking('Phase 1: Building ranking requests for ' + classes.length + ' weight classes');\n  const rankingRequests = classes.map(wc => {\n    const url = BASE_URL + '/api/categories/all/rankings/table/data?p=0&l=3&s=';\n    const payload = {\n      columns: [],\n      filters: { date_range_start: startDate, date_range_end: endDate, weight_class: wc.value, wso: wsoName }\n    };\n\n    return {\n      url: url,\n      options: {\n        method: 'POST',\n        headers: { 'x-api-token': API_TOKEN, 'Content-Type': 'application/json' },\n        payload: JSON.stringify(payload)\n      }\n    };\n  });\n\n  // Execute all ranking requests in parallel\n  thinking('Executing ' + rankingRequests.length + ' ranking requests in parallel');\n  const UrlFetchUtils = require('common-js/UrlFetchUtils');\n  const rankingResults = UrlFetchUtils.fetchAllWithRetry(rankingRequests, {\n    continueOnError: true,\n    maxTotalTimeMs: 120000,\n    think: thinking\n  });\n\n  thinking('Phase 1 complete in ' + (Date.now() - startTime) + 'ms');\n\n  // PHASE 2: Collect all lifter history IDs from successful ranking responses\n  thinking('Phase 2: Collecting lifter history IDs from ranking results');\n  const lifterHistoryRequests = [];\n  const lifterMetadata = []; // Track which lifter belongs to which weight class\n\n  rankingResults.responses.forEach((response, idx) => {\n    // Show progress every 10 classes or at end\n    if (idx % 10 === 0 || idx === rankingResults.responses.length - 1) {\n      thinking('Phase 2: Processing weight class ' + (idx + 1) + '/' + rankingResults.responses.length);\n    }\n\n    if (response.__error) {\n      thinking('Ranking request failed for ' + classes[idx].text + ': ' + response.__error);\n      return;\n    }\n\n    if (response.getResponseCode() !== 200) {\n      thinking('Ranking request returned status ' + response.getResponseCode() + ' for ' + classes[idx].text);\n      return;\n    }\n\n    let data;\n    try {\n      data = JSON.parse(response.getContentText());\n    } catch (e) {\n      thinking('Failed to parse ranking response for ' + classes[idx].text);\n      return;\n    }\n\n    const lifters = data.data || [];\n    if (lifters.length === 0) {\n      thinking('No lifters found for ' + classes[idx].text);\n      return;\n    }\n\n    // Extract history IDs from top 3 lifters\n    lifters.slice(0, 3).forEach(lifter => {\n      const historyId = lifter.action?.[0]?.route?.match(/\\/member\\/(\\d+)/)?.[1];\n      if (!historyId) return;\n\n      lifterHistoryRequests.push({\n        url: BASE_URL + '/api/athletes/' + historyId + '/table/data',\n        options: {\n          method: 'POST',\n          headers: { 'x-api-token': API_TOKEN, 'Content-Type': 'application/json' },\n          payload: '{}'\n        }\n      });\n\n      lifterMetadata.push({\n        weightClass: classes[idx],\n        lifter: lifter,\n        historyId: historyId\n      });\n    });\n  });\n\n  thinking('Found ' + lifterHistoryRequests.length + ' lifter histories to fetch');\n\n  if (lifterHistoryRequests.length === 0) {\n    thinking('No lifters found across any weight classes');\n    return {\n      wso: wsoName,\n      records: [],\n      classes_searched: classes.length,\n      hints: { message: 'No records found for this WSO in the specified date range' }\n    };\n  }\n\n  // Execute all history requests in parallel\n  const phase2StartTime = Date.now();\n  thinking('Executing ' + lifterHistoryRequests.length + ' history requests in parallel');\n  const historyResults = UrlFetchUtils.fetchAllWithRetry(lifterHistoryRequests, {\n    continueOnError: true,\n    maxTotalTimeMs: 120000,\n    think: thinking\n  });\n\n  thinking('Phase 2 complete in ' + (Date.now() - phase2StartTime) + 'ms');\n\n  // PHASE 3: Combine ranking and history data to build records\n  thinking('Phase 3: Building records from history data');\n  const recordsMap = {}; // Key: weight_class_id, Value: classRecord object\n\n  historyResults.responses.forEach((response, idx) => {\n    // Show progress every 25 histories or at milestones\n    if (idx % 25 === 0 || idx === historyResults.responses.length - 1) {\n      const currentRecordCount = Object.keys(recordsMap).length;\n      thinking('Phase 3: Processing history ' + (idx + 1) + '/' + historyResults.responses.length + ' (' + currentRecordCount + ' records found)');\n    }\n\n    const metadata = lifterMetadata[idx];\n\n    if (response.__error) {\n      thinking('History request failed for lifter ' + metadata.historyId + ': ' + response.__error);\n      return;\n    }\n\n    if (response.getResponseCode() !== 200) {\n      return;\n    }\n\n    let histData;\n    try {\n      histData = JSON.parse(response.getContentText());\n    } catch (e) {\n      return;\n    }\n\n    // Initialize class record if not exists\n    const wcId = metadata.weightClass.value;\n    if (!recordsMap[wcId]) {\n      recordsMap[wcId] = {\n        weight_class: metadata.weightClass.text,\n        weight_class_id: wcId,\n        snatch: null,\n        clean_jerk: null,\n        total: null\n      };\n    }\n\n    const classRecord = recordsMap[wcId];\n    const lifter = metadata.lifter;\n\n    // Find best lifts from history\n    for (const r of histData.data || []) {\n      const sn = r.best_snatch;\n      const cj = r['best_c&j'];\n      const tot = r.total;\n      const makeRecord = (kg) => ({\n        kg: kg,\n        lifter: lifter.name,\n        member_id: lifter.membership,\n        date: r.date,\n        event: r.meet\n      });\n\n      if (sn && (!classRecord.snatch || sn > classRecord.snatch.kg)) {\n        classRecord.snatch = makeRecord(sn);\n      }\n      if (cj && (!classRecord.clean_jerk || cj > classRecord.clean_jerk.kg)) {\n        classRecord.clean_jerk = makeRecord(cj);\n      }\n      if (tot && (!classRecord.total || tot > classRecord.total.kg)) {\n        classRecord.total = makeRecord(tot);\n      }\n    }\n  });\n\n  // Convert map to array, filtering out empty records\n  const records = Object.values(recordsMap).filter(rec =>\n    rec.snatch || rec.clean_jerk || rec.total\n  );\n\n  const totalTime = Date.now() - startTime;\n  thinking('Found records for ' + records.length + ' weight classes in ' + totalTime + 'ms');\n  thinking('Performance: ' + (rankingRequests.length + lifterHistoryRequests.length) + ' total API calls in 2 parallel batches');\n\n  return {\n    wso: wsoName,\n    records: records,\n    classes_searched: classes.length,\n    api_calls_made: rankingRequests.length + lifterHistoryRequests.length,\n    execution_time_ms: totalTime,\n    hints: { nextTools: ['usaw_lifter_history: pass member_id for athlete details'] }\n  };\n}\n\n__defineModule__(_main);",
    "enabled": true,
    "returns": "{wso, records[{weight_class, snatch?, clean_jerk?, total?}], classes_searched, api_calls_made, execution_time_ms, hints?, error?, details?}"
  },
  {
    "name": "iwf_events",
    "description": "List IWF events (competitions) by year. Returns event IDs, names, dates, locations for results lookup.",
    "params": "year = \"\"",
    "implementation": "function _main(\n  module = globalThis.__getCurrentModule(),\n  exports = module.exports,\n  log = globalThis.__getModuleLogFunction?.(module) || (() => {})\n) {\n  const BASE_URL = 'https://iwf.sport/results/results-by-events/';\n\n  // Determine year - default to current year\n  let year = input.year || new Date().getFullYear().toString();\n\n  // Normalize to string\n  year = String(year).trim();\n\n  // Parse and validate year\n  const yearNum = parseInt(year);\n\n  if (isNaN(yearNum)) {\n    return {\n      error: 'Invalid year format',\n      details: 'Year must be numeric',\n      hints: {\n        provided: input.year,\n        example: 'year: 2024 or year: \"2024\"'\n      }\n    };\n  }\n\n  if (yearNum < 1950 || yearNum > 2050) {\n    return {\n      error: 'Year out of range',\n      details: 'Year must be between 1950 and 2050',\n      hints: {\n        provided: yearNum,\n        reason: 'IWF events data only available for recent/near-future years'\n      }\n    };\n  }\n\n  year = yearNum.toString();\n\n  thinking('Fetching IWF events for ' + year);\n\n  // Fetch the events page\n  const url = BASE_URL + '?event_year=' + encodeURIComponent(year);\n  let resp;\n\n  try {\n    resp = UrlFetchApp.fetch(url, {\n    muteHttpExceptions: true,\n      headers: {\n        'User-Agent': 'Mozilla/5.0 (compatible; GAS)',\n        'Accept': 'text/html'\n      }\n    });\n  } catch (e) {\n    return {\n      error: 'Network error fetching IWF events',\n      details: e.message,\n      hints: {\n        url: url,\n        possibleCauses: [\n          'Network timeout (>60 seconds)',\n          'DNS resolution failure',\n          'IWF website temporarily down',\n          'Blocked by firewall or rate limiting'\n        ],\n        action: 'Try again in a few minutes or check IWF website directly'\n      }\n    };\n  }\n\n  thinking('Successfully fetched IWF events page for ' + year);\n\n  if (resp.getResponseCode() !== 200) {\n    return {\n      error: 'Failed to fetch IWF events page',\n      details: 'HTTP ' + resp.getResponseCode(),\n      hints: {\n        url: url,\n        statusCode: resp.getResponseCode(),\n        possibleReasons: resp.getResponseCode() === 403\n          ? 'User-agent blocked by IWF website'\n          : 'IWF website may be temporarily unavailable'\n      }\n    };\n  }\n\n  thinking('Parsing HTML to extract event details...');\n\n  const html = resp.getContentText();\n\n  // Parse events from HTML - events are in <a href=\"?event_id=XXX\"> tags\n  // The content follows pattern: EventName ... Date ... Location, COUNTRY\n  const events = [];\n\n  // Find all event links with event_id\n  const linkRegex = /<a[^>]*href=[\"']?\\?event_id=(\\d+)[\"']?[^>]*>([\\s\\S]*?)<\\/a>/gi;\n  let match;\n\n  while ((match = linkRegex.exec(html)) !== null) {\n    const eventId = match[1];\n    const content = match[2];\n\n    // Clean HTML tags and normalize whitespace\n    const text = content.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ').trim();\n\n    // Skip if it's just \"More info\" or too short\n    if (text.length < 10 || text.toLowerCase() === 'more info') continue;\n\n    // Parse the content: \"EventName Date Location, COUNTRY More info\"\n    // Date format: \"Mon DD, YYYY\" e.g., \"Nov 10, 2025\"\n    const dateMatch = text.match(/([A-Z][a-z]{2}\\s+\\d{1,2},\\s+\\d{4})/);\n    const date = dateMatch ? dateMatch[1] : null;\n\n    // Country code at end (3 uppercase letters)\n    const countryMatch = text.match(/,\\s*([A-Z]{3})\\s*(?:More info)?$/);\n    const country = countryMatch ? countryMatch[1] : null;\n\n    // Location is between date and country\n    let location = null;\n    let name = text;\n\n    if (date && country) {\n      const parts = text.split(date);\n      name = parts[0].trim();\n\n      // Extract location from after date\n      const afterDate = parts[1] || '';\n      const locMatch = afterDate.match(/^\\s*(.+?),\\s*[A-Z]{3}/);\n      if (locMatch) {\n        location = locMatch[1].trim();\n      }\n    } else if (date) {\n      name = text.split(date)[0].trim();\n    }\n\n    // Remove \"More info\" from name if present\n    name = name.replace(/More info/gi, '').trim();\n\n    // Skip duplicates (same event_id)\n    if (events.some(e => e.event_id === eventId)) continue;\n\n    events.push({\n      event_id: eventId,\n      name: name,\n      date: date,\n      location: location,\n      country: country\n    });\n  }\n\n  thinking('Found ' + events.length + ' events');\n\n  if (events.length === 0) {\n    return {\n      events: [],\n      year: year,\n      count: 0,\n      hints: {\n        message: 'No events found for ' + year,\n        suggestion: 'Try a different year or check IWF website directly',\n        url: BASE_URL + '?event_year=' + year\n      }\n    };\n  }\n\n  if (events.length === 0) {\n    return {\n      events: [],\n      year: year,\n      count: 0,\n      hints: {\n        message: 'No events found for ' + year,\n        suggestion: 'Try a different year or check IWF website directly',\n        url: BASE_URL + '?event_year=' + year\n      }\n    };\n  }\n\n  return {\n    events: events,\n    year: year,\n    count: events.length,\n    hints: {\n      nextTools: ['iwf_event_results: pass event_id to get competition results']\n    }\n  };\n}\n\n__defineModule__(_main);",
    "enabled": true,
    "returns": "{events[{event_id, name, date?, location?, country?}], year, count, hints?, error?, details?}"
  },
  {
    "name": "iwf_event_results",
    "description": "Get results from an IWF event. Returns athlete rankings with lifts. Use iwf_events first to get event_id.",
    "params": "event_id!, weight_class = \"\"",
    "implementation": "if (!input.event_id) return { error: 'event_id is required' };\n\nthinking('Fetching IWF event ' + input.event_id);\n\nconst url = 'https://iwf.sport/results/results-by-events/?event_id=' + input.event_id;\nconst resp = UrlFetchApp.fetch(url, { muteHttpExceptions: true });\n\nif (resp.getResponseCode() !== 200) {\n  return { error: 'Failed to fetch', details: 'HTTP ' + resp.getResponseCode() };\n}\n\nconst html = resp.getContentText();\nconst results = [];\n\n// Find weight class headers\nconst wcRegex = /<h2[^>]*>([^<]*kg[^<]*)<\\/h2>/gi;\nvar wcMatch;\nconst wcs = [];\nwhile ((wcMatch = wcRegex.exec(html)) !== null) {\n  wcs.push({ name: wcMatch[1].trim(), idx: wcMatch.index });\n}\n\nif (wcs.length === 0) return { error: 'No weight classes found' };\nthinking('Found ' + wcs.length + ' weight classes');\n\n// Simple card parsing - find all athlete cards\nvar allCards = html.split('<div class=\"card\">');\n\nfor (var i = 0; i < wcs.length; i++) {\n  var wc = wcs[i];\n  if (input.weight_class && wc.name.toLowerCase().indexOf(input.weight_class.toLowerCase()) === -1) continue;\n\n  var nextIdx = wcs[i+1] ? wcs[i+1].idx : html.length;\n  var section = html.substring(wc.idx, nextIdx);\n  var athletes = [];\n\n  // Find rank, country, snatch, c&j, total in section using simple patterns\n  var rankMatches = section.match(/Rank:[^<]*<\\/span>\\s*(\\d+)/g) || [];\n  var countryMatches = section.match(/([A-Z]{3})\\.png/g) || [];\n  var snatchMatches = section.match(/Snatch:[^<]*<\\/span><strong>(\\d+|---)/g) || [];\n  var cjMatches = section.match(/CI&Jerk:[^<]*<\\/span><strong>(\\d+|---)/g) || [];\n  var totalMatches = section.match(/Total:[^<]*<\\/span><strong>(\\d+|---)/g) || [];\n\n  var count = Math.min(rankMatches.length, countryMatches.length, snatchMatches.length);\n  for (var j = 0; j < count; j++) {\n    var rank = rankMatches[j].match(/(\\d+)/); rank = rank ? parseInt(rank[1]) : null;\n    var country = countryMatches[j].match(/([A-Z]{3})/); country = country ? country[1] : null;\n    var sn = snatchMatches[j].match(/(\\d+|---)/); sn = sn && sn[1] !== '---' ? parseInt(sn[1]) : null;\n    var cj = cjMatches[j] ? cjMatches[j].match(/(\\d+|---)/) : null; cj = cj && cj[1] !== '---' ? parseInt(cj[1]) : null;\n    var tot = totalMatches[j] ? totalMatches[j].match(/(\\d+|---)/) : null; tot = tot && tot[1] !== '---' ? parseInt(tot[1]) : null;\n    athletes.push({ rank: rank, country: country, snatch: sn, clean_jerk: cj, total: tot });\n  }\n\n  if (athletes.length > 0) results.push({ weight_class: wc.name, athletes: athletes });\n}\n\nreturn { event_id: input.event_id, results: results, count: results.length };",
    "enabled": true,
    "returns": "{event_id, results: [{weight_class, athletes: [{rank, name, country, bodyweight, snatch, clean_jerk, total}]}], hints}"
  },
  {
    "name": "usaw_events",
    "description": "List USAW events/competitions by date range. Returns all events with pagination. Filters: name_filter, level (Local/Regional/National), state.",
    "params": "date_range_start!, date_range_end!, limit = 50, name_filter = \"\", level = \"\", state = \"\"",
    "implementation": "const API_TOKEN = '14ced0f3-421f-4acf-94ad-cc63a371af19';\nconst BASE_URL = 'https://admin-usaw-rankings.sport80.com';\n\nif (!input.date_range_start || !input.date_range_end) {\n  return { error: 'date_range_start and date_range_end required (YYYY-MM-DD)' };\n}\n\nvar pageSize = input.limit || 50;\nthinking('Fetching USAW events ' + input.date_range_start + ' to ' + input.date_range_end);\n\nvar allEvents = [];\nvar page = 0;\nvar hasMore = true;\n\nwhile (hasMore) {\n  thinking('Fetching page ' + page + ' (' + allEvents.length + ' events so far)');\n\n  var url = BASE_URL + '/api/events/table/data?p=' + page + '&l=' + pageSize;\n  var payload = { columns: [], filters: { date_range_start: input.date_range_start, date_range_end: input.date_range_end } };\n\n  var resp = UrlFetchApp.fetch(url, {\n    method: 'POST',\n    headers: { 'x-api-token': API_TOKEN, 'Content-Type': 'application/json' },\n    payload: JSON.stringify(payload),\n    muteHttpExceptions: true\n  });\n\n  if (resp.getResponseCode() !== 200) {\n    return { error: 'API returned ' + resp.getResponseCode(), details: resp.getContentText().substring(0, 200) };\n  }\n\n  var data;\n  try { data = JSON.parse(resp.getContentText()); }\n  catch (e) { return { error: 'Invalid JSON', details: resp.getContentText().substring(0, 200) }; }\n\n  var events = data.data || [];\n  events.forEach(function(e) {\n    var eventId = null;\n    if (e.action && e.action[0] && e.action[0].route) {\n      var match = e.action[0].route.match(/\\/public\\/rankings\\/results\\/(\\d+)/);\n      if (match) eventId = match[1];\n    }\n    var evt = {\n      event_id: eventId,\n      name: e.meet,\n      level: e.level,\n      date: e.date,\n      results_count: e.results_count || e.results\n    };\n\n    // Apply filters\n    if (input.name_filter && evt.name && !evt.name.toLowerCase().includes(input.name_filter.toLowerCase())) return;\n    if (input.level && evt.level && !evt.level.toLowerCase().includes(input.level.toLowerCase())) return;\n    if (input.state && evt.name && !evt.name.toLowerCase().includes(input.state.toLowerCase())) return;\n\n    allEvents.push(evt);\n  });\n\n  hasMore = events.length > 0 && events.length >= pageSize;\n  page++;\n  if (page > 100) break;\n}\n\nthinking('Found ' + allEvents.length + ' total events');\n\nreturn {\n  events: allEvents,\n  count: allEvents.length,\n  hints: { nextTools: ['usaw_event_results: pass event_id for detailed results'] }\n};",
    "enabled": true,
    "returns": "{events: [{event_id, name, level, date, results_count}], total: number, page: number}"
  },
  {
    "name": "usaw_event_results",
    "description": "Get results from USAW events. Use event_name regex with date_range to search multiple events, OR provide event_id for a specific event. Filters: weight_class, athlete_name.",
    "params": "event_name = \"\", event_id = \"\", date_range_start = \"\", date_range_end = \"\", limit = 50, weight_class = \"\", athlete_name = \"\"",
    "implementation": "function _main(\n  module = globalThis.__getCurrentModule(),\n  exports = module.exports,\n  log = globalThis.__getModuleLogFunction?.(module) || (() => {})\n) {\n  /**\n   * Reference implementation for usaw_event_results tool\n   * Demonstrates UNION/FILTER pattern with helper functions\n   * \n   * UNION Parameters (multiple API calls):\n   *   - divisions[]\n   *   - weight_classes[]\n   * \n   * FILTER Parameters (client-side filtering):\n   *   - athlete_names[]\n   *   - wsos[]\n   *   - gender\n   *   - min_total / max_total\n   *   - sort_by\n   *   - top_n\n   */\n\n  let FilterHelpers, Normalizers;\n\n  try {\n    FilterHelpers = require('tools/helpers/UsawFilterHelpers');\n  } catch (e) {\n    return {\n      error: 'Failed to load UsawFilterHelpers module',\n      details: e.message,\n      hints: {\n        message: 'Helper module may be missing or corrupted',\n        action: 'Verify tools/helpers/UsawFilterHelpers.gs exists'\n      }\n    };\n  }\n\n  try {\n    Normalizers = require('tools/helpers/UsawNormalizers');\n  } catch (e) {\n    return {\n      error: 'Failed to load UsawNormalizers module',\n      details: e.message,\n      hints: {\n        message: 'Helper module may be missing or corrupted',\n        action: 'Verify tools/helpers/UsawNormalizers.gs exists'\n      }\n    };\n  }\n\n  /**\n   * Get results from a USAW competition event\n   * @param {Object} input - Tool input parameters\n   * @return {Object} Tool result with event results\n   */\n  function usaw_event_results(input) {\n    // Validate required event_id parameter\n    if (!input.event_id) {\n      return {\n        error: 'event_id is required',\n        details: 'Provide the USAW event ID',\n        hints: {\n          example: 'event_id: \"12345\"',\n          howToFind: 'Find event ID on USAW event page URL'\n        }\n      };\n    }\n\n    const eventId = String(input.event_id).trim();\n\n    // Validate event_id format\n    if (!/^\\d+$/.test(eventId)) {\n      return {\n        error: 'Invalid event_id format',\n        details: 'Event ID must be numeric',\n        hints: {\n          provided: input.event_id,\n          example: 'event_id: \"12345\"'\n        }\n      };\n    }\n\n    if (eventId.length > 20) {\n      return {\n        error: 'Event ID too long',\n        details: 'Event IDs are typically 5-10 digits',\n        hints: {\n          provided: eventId.substring(0, 20) + '...'\n        }\n      };\n    }\n\n    thinking('Fetching results for event ' + eventId);\n\n    // Parse and normalize UNION parameters\n    var divisions = input.divisions || [];\n    var weightClasses = Normalizers.parseWeightClasses(input.weight_classes);\n\n    // If divisions or weight classes provided, ensure they're arrays\n    if (divisions && !Array.isArray(divisions)) {\n      divisions = [divisions];\n    }\n    if (weightClasses && !Array.isArray(weightClasses)) {\n      weightClasses = [weightClasses];\n    }\n\n    // Estimate API call count\n    thinking('Parsing UNION parameters: divisions=' + (divisions.length || 0) + ', weight_classes=' + (weightClasses.length || 0));\n\n    var estimatedCalls = FilterHelpers.estimateAndWarnApiCalls({\n      divisions: divisions.length > 0 ? divisions : undefined,\n      weight_classes: weightClasses.length > 0 ? weightClasses : undefined\n    });\n\n    // Define request builder for batch mode (parallel execution)\n    function buildEventResultsRequest(params) {\n      var queryParams = [];\n      if (params.division) queryParams.push('division=' + encodeURIComponent(params.division));\n      if (params.weight_class) queryParams.push('weight_class=' + encodeURIComponent(params.weight_class));\n\n      var url = 'https://admin-usaw-rankings.sport80.com/api/events/' + input.event_id + '/results';\n      if (queryParams.length > 0) {\n        url += '?' + queryParams.join('&');\n      }\n\n      return {\n        url: url,\n        method: 'GET',\n        headers: {\n          'x-api-token': PropertiesService.getScriptProperties().getProperty('USAW_API_TOKEN') || ''\n        }\n      };\n    }\n\n    // Define response parser for batch mode\n    function parseEventResultsResponse(response) {\n      if (response.getResponseCode() !== 200) {\n        throw new Error('HTTP ' + response.getResponseCode() + ': ' + response.getContentText());\n      }\n      return JSON.parse(response.getContentText());\n    }\n\n    // Execute UNION operations in batch mode (parallel)\n    const totalCalls = (divisions.length || 1) * (weightClasses.length || 1);\n    thinking('Starting UNION query: ' + totalCalls + ' API calls');\n    thinking('This may take 30-60 seconds for large queries...');\n    \n    var unionParams = {};\n    if (divisions.length > 0) unionParams.division = divisions;\n    if (weightClasses.length > 0) unionParams.weight_class = weightClasses;\n\n    var unionResult = FilterHelpers.executeUnion({\n      unionParams: unionParams,\n      buildRequestFn: buildEventResultsRequest,\n      parseResponseFn: parseEventResultsResponse,\n      dedupeKey: 'athlete_id'\n    });\n\n    thinking('UNION complete: fetched ' + (unionResult.results ? unionResult.results.length : 0) + ' raw results');\n\n    if (!unionResult.success) {\n      return unionResult;  // Return error\n    }\n\n    var allResults = unionResult.results;\n    var apiCallsMade = unionResult.api_calls_made;\n\n    // Apply FILTER parameters\n    var filtered = FilterHelpers.applyFilters(allResults, {\n      wsos: input.wsos,\n      athlete_names: input.athlete_names,\n      gender: input.gender,\n      min_total: input.min_total,\n      max_total: input.max_total\n    });\n\n    const activeFilters = Object.keys(input).filter(k => input[k] && k !== 'event_id').length;\n    if (activeFilters > 0) {\n      thinking('Applied ' + activeFilters + ' filters: ' + filtered.length + ' results (from ' + allResults.length + ')');\n    }\n\n    // Apply sorting\n    if (input.sort_by) {\n      filtered = FilterHelpers.applySorting(filtered, input.sort_by);\n    }\n\n    // Apply top_n limit\n    if (input.top_n && input.top_n > 0) {\n      filtered = FilterHelpers.applyTopN(filtered, input.top_n);\n    }\n\n    thinking('Returning ' + filtered.length + ' event results');\n\n    return {\n      event_id: eventId,\n      api_calls_made: apiCallsMade,\n      total_results: allResults.length,\n      filtered_results: filtered.length,\n      results: filtered\n    };\n  }\n\n  module.exports = usaw_event_results;\n}\n\n__defineModule__(_main);",
    "enabled": true,
    "returns": "{event_id, api_calls_made, total_results, filtered_results, results[], hints?, error?, details?}"
  },
  {
    "name": "usaw_event_entries",
    "description": "Get registered lifters for upcoming USAW events. Use event_name regex to search multiple events, OR provide event_id + entries_id for a specific event. Filters: division, weight_class, athlete_name.",
    "params": "event_name = \"\", event_id = \"\", entries_id = \"\", limit = 50, division = \"\", weight_class = \"\", athlete_name = \"\"",
    "implementation": "var LOCATOR_URL = 'https://usaweightlifting.sport80.com/api/public/events/locator/data';\nvar ENTRIES_URL = 'https://usaweightlifting.sport80.com/api/public/events/datatable';\nvar pageSize = input.limit || 50;\n\nfunction fetchEntries(eventId, entriesId) {\n  var allEntries = [], page = 0, hasMore = true, total = 0;\n  while (hasMore) {\n    var url = ENTRIES_URL + '/' + eventId + '/entries/' + entriesId + '?data=1&bl=locator&p=' + page + '&l=' + pageSize;\n    var resp = UrlFetchApp.fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, payload: JSON.stringify({ columns: [], filters: {} }), muteHttpExceptions: true });\n    if (resp.getResponseCode() !== 200) return { error: 'API ' + resp.getResponseCode() };\n    var data; try { data = JSON.parse(resp.getContentText()); } catch (e) { return { error: 'Invalid JSON' }; }\n    total = data.total || total;\n    var items = data.data || [];\n    items.forEach(function(e) {\n      var entry = { member_id: e.member_id, name: (e.first_name||'') + ' ' + (e.last_name||'').replace(/ \\\\([^)]+\\\\)$/, ''), state: e.state, year_of_birth: e.year_of_birth, age: e.weightlifting_age, club: e.club, gender: e.gender, division: e.division, weight_class: e.weight_class, entry_total: e.entry_total };\n      if (input.division && entry.division && !entry.division.toLowerCase().includes(input.division.toLowerCase())) return;\n      if (input.weight_class && entry.weight_class && !entry.weight_class.toLowerCase().includes(input.weight_class.toLowerCase())) return;\n      if (input.athlete_name && entry.name && !entry.name.toLowerCase().includes(input.athlete_name.toLowerCase())) return;\n      allEntries.push(entry);\n    });\n    hasMore = items.length > 0 && items.length >= pageSize; page++; if (page > 100) break;\n  }\n  return { entries: allEntries, total: total };\n}\nif (input.event_name) {\n  thinking('Searching upcoming events matching: ' + input.event_name);\n  var regex;\n  try { regex = new RegExp(input.event_name, 'i'); } catch (e) { return { error: 'Invalid regex pattern: ' + e.message }; }\n  var fromDate = new Date().toISOString().split('T')[0];\n  var allEvents = [], page = 0, hasMore = true, searchError = null;\n  while (hasMore) {\n    var boundary = '----FormBoundary' + Math.random().toString(36).substr(2);\n    var body = '--' + boundary + '\\r\\nContent-Disposition: form-data; name=\"from_date\"\\r\\n\\r\\n' + fromDate + '\\r\\n--' + boundary + '--';\n    var resp = UrlFetchApp.fetch(LOCATOR_URL + '?p=' + page + '&i=' + pageSize + '&s=&l=&d=10&f=', {\n      method: 'POST', headers: { 'Content-Type': 'multipart/form-data; boundary=' + boundary }, payload: body, muteHttpExceptions: true\n    });\n    if (resp.getResponseCode() !== 200) { searchError = 'Event search API returned ' + resp.getResponseCode(); break; }\n    var data; try { data = JSON.parse(resp.getContentText()); } catch (e) { searchError = 'Invalid JSON from event search'; break; }\n    var items = data.data || [];\n    items.forEach(function(e) {\n      var entriesMatch = (e.action || '').match(/\\/events\\/(\\d+)\\/entries\\/(\\d+)/);\n      if (entriesMatch && regex.test(e.name)) {\n        allEvents.push({ event_id: entriesMatch[1], entries_id: entriesMatch[2], name: e.name, date: e.start_date, location: e.location });\n      }\n    });\n    hasMore = items.length > 0 && items.length >= pageSize; page++; if (page > 50) break;\n  }\n  if (searchError && allEvents.length === 0) return { error: searchError };\n  thinking('Found ' + allEvents.length + ' matching events, fetching entries...');\n  var results = allEvents.map(function(evt) {\n    thinking('Fetching entries for: ' + evt.name);\n    var entriesResult = fetchEntries(evt.event_id, evt.entries_id);\n    return { event_name: evt.name, event_id: evt.event_id, entries_id: evt.entries_id, date: evt.date, location: evt.location, entries: entriesResult.entries || [], total: entriesResult.total || 0, error: entriesResult.error };\n  });\n  return { events: results, event_count: results.length, total_entries: results.reduce(function(s,e){return s+(e.entries||[]).length;},0), search_warning: searchError };\n}\nif (!input.event_id || !input.entries_id) return { error: 'Provide event_name regex OR both event_id and entries_id' };\nthinking('Fetching entries for event ' + input.event_id);\nvar result = fetchEntries(input.event_id, input.entries_id);\nif (result.error) return result;\nvar byDiv = result.entries.reduce(function(a,e) { var d=e.division; if(!a[d])a[d]=[]; a[d].push(e); return a; }, {});\nvar grouped = Object.keys(byDiv).sort().map(function(d) { return { division: d, entries: byDiv[d].sort(function(a,b){return (b.entry_total||0)-(a.entry_total||0);}) }; });\nreturn { event_id: input.event_id, entries_id: input.entries_id, results: grouped, total: result.total, entry_count: result.entries.length, division_count: grouped.length };",
    "enabled": true,
    "returns": "{event_id, entries_id, results: [{division, entries: [...]}], total, entry_count, division_count}"
  },
  {
    "name": "usaw_filter_options",
    "description": "Get available filter options (divisions, weight classes, clubs, WSOs, states) for USAW tools. Returns metadata for building dynamic filters and dropdowns.",
    "params": "filter_type",
    "implementation": "function _main(\n  module = globalThis.__getCurrentModule(),\n  exports = module.exports,\n  log = globalThis.__getModuleLogFunction?.(module) || (() => {})\n) {\n  /**\n   * Implementation for usaw_filter_options discovery tool\n   * Allows Claude to discover available filter options from USAW API\n   * \n   * Filter types:\n   *   - weight_class: Available weight classes with IDs\n   *   - wso: WSO regions with IDs\n   *   - club: Club options with IDs\n   *   - level: Competition levels with IDs\n   *   - event_type: Event types (Meets, Courses, etc.)\n   *   - state: States/regions for events\n   *   - all: Get all available filter types\n   */\n\n  let MetadataCache;\n\n  try {\n    MetadataCache = require('tools/helpers/UsawMetadataCache');\n  } catch (e) {\n    return {\n      error: 'Failed to load UsawMetadataCache module',\n      details: e.message,\n      hints: {\n        message: 'Helper module may be missing or corrupted',\n        action: 'Verify tools/helpers/UsawMetadataCache.gs exists'\n      }\n    };\n  }\n\n  /**\n   * Discover available filter options for USAW tools\n   * @param {Object} input - Tool input parameters\n   * @return {Object} Tool result with filter options\n   */\n  function usaw_filter_options(input) {\n    var filterType = (input.filter_type || 'all').toLowerCase();\n\n    if (filterType === 'all') {\n      thinking('Fetching all filter metadata from USAW API');\n    } else {\n      thinking('Fetching filter options for: ' + filterType);\n    }\n\n    if (filterType === 'all') {\n      thinking('Fetching all filter metadata from USAW API');\n    } else {\n      thinking('Fetching filter options for: ' + filterType);\n    }\n\n    // If requesting all or no specific type\n    if (!input.filter_type || filterType === 'all') {\n      var meta = MetadataCache.getRankingsFilterMeta();\n      if (!meta) {\n        return { error: 'Failed to fetch filter metadata from USAW API' };\n      }\n      return {\n        filter_types: ['weight_class', 'wso', 'club', 'level', 'event_type', 'state'],\n        note: 'Use filter_type parameter to get specific options',\n        metadata: {\n          weight_class: formatMapToOptions(meta.weightClassMap),\n          wso: formatMapToOptions(meta.wsoMap || {}),\n          club: formatMapToOptions(meta.clubMap || {}),\n          level: formatMapToOptions(meta.levelMap || {})\n        }\n      };\n    }\n\n    var validTypes = ['weight_class', 'wso', 'club', 'level', 'event_type', 'state'];\n    \n    if (validTypes.indexOf(filterType) === -1) {\n      return {\n        error: 'Invalid filter_type: ' + input.filter_type,\n        valid_types: validTypes\n      };\n    }\n\n    // Handle event_type and state separately (from events API)\n    if (filterType === 'event_type' || filterType === 'state') {\n      var eventsMeta = MetadataCache.getEventsFilterMeta();\n      if (!eventsMeta) {\n        return { error: 'Failed to fetch events filter metadata from USAW API' };\n      }\n\n      if (filterType === 'event_type') {\n        return {\n          filter_type: 'event_type',\n          count: Object.keys(eventsMeta.eventTypeMap).length / 2,\n          options: formatMapToOptions(eventsMeta.eventTypeMap)\n        };\n      }\n\n      if (filterType === 'state') {\n        return {\n          filter_type: 'state',\n          count: Object.keys(eventsMeta.stateMap).length / 2,\n          options: formatMapToOptions(eventsMeta.stateMap)\n        };\n      }\n    }\n\n    // Handle rankings filters (weight_class, wso, club, level)\n    var rankingsMeta = MetadataCache.getRankingsFilterMeta();\n    if (!rankingsMeta) {\n      return { error: 'Failed to fetch rankings filter metadata from USAW API' };\n    }\n\n    var mapKey = filterType + 'Map';\n    var map = rankingsMeta[mapKey];\n\n    if (!map) {\n      return { error: 'No metadata found for filter type: ' + filterType };\n    }\n\n    const options = formatMapToOptions(map);\n    thinking('Retrieved ' + options.length + ' options for ' + filterType);\n    \n    return {\n      filter_type: filterType,\n      count: options.length,\n      options: options\n    };\n  }\n\n  /**\n   * Format metadata map to array of {id, name} options\n   * Filters to only numeric IDs (excludes the reverse nameid mappings)\n   * @param {Object} map - Metadata map with bidirectional IDname mapping\n   * @return {Array<Object>} Array of {id, name} objects\n   */\n  function formatMapToOptions(map) {\n    if (!map) return [];\n\n    var options = [];\n    Object.keys(map).forEach(function(key) {\n      // Only include numeric/string ID keys (not the lowercase name keys)\n      if (/^\\d+$/.test(key) || (key === key.toUpperCase() && key.length < 10)) {\n        options.push({\n          id: key,\n          name: map[key]\n        });\n      }\n    });\n\n    // Sort alphabetically by name\n    options.sort(function(a, b) {\n      var nameA = String(a.name).toLowerCase();\n      var nameB = String(b.name).toLowerCase();\n      return nameA.localeCompare(nameB);\n    });\n\n    return options;\n  }\n\n  module.exports = usaw_filter_options;\n}\n\n__defineModule__(_main);",
    "enabled": true,
    "returns": "Case 1: {filter_types[], note, metadata{}} | Case 2: {filter_type, count, options[]}"
  }
]
